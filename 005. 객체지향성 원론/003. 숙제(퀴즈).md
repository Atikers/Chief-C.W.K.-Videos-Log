# [대두족장 인생 치트키 객체지향성 원론] Part 03 - 숙제(퀴즈)

**영상링크 : https://youtu.be/2Cyr_jDs2G8**

## ***숙제 주의 사항***

안 지키면 효과 없음

원론 part 01, 02 숙지하고 고정댓글에 달린 문제 다 풀고 오셔야 합니다.

서두를수록 시간낭비일 뿐이니 slow & steady.

```
객체지향성의 기본은 세상 만물 + 개념을 진화 가능한 생명체로 단순화하는 연습입니다.

"A와 B의 공통분모와 개성"이 아니라 "A와 B는 동일 조상 클래스에서 상속 받으며, A와 B는 다형성이 추가된다"라는 식으로 설명해야 하는 이윱니다.

말로 해야 합니다.

본인 목소리를 귀로 들으면서 하세요. 각잡고 문장이 이어지도록 또박 또박 제스처를 써가며 강단에 선 듯 설명하세요. 얼버부리면 효과 없습니다. 일타 강사가 되세요.

녹음 또는 영상 촬영하세요. 카메라 보면서 청중에게 설명하듯 하면 한결 쉽고 재미있습니다.

각 문제는 3-5분 정도 설명할 수 있어야 합니다. 단답형으로 대충하면 효과 없습니다.

정답 없습니다. 본인이 만족할 때까지 반복하세요.
```

## ***퀴즈***

### ***1***

세상 만물(개념 포함)은 속성(properties)과 메소드(methods)로 설명할 수 있습니다. 

객체지향성에서는 도트 노테이션을 사용합니다. a.name은 속성 a.speak()는 메소드입니다.

예) 렌즈
속성: lens.name = SEL2470GM
메소드: lens.zoom()

예) 유튜브 동영상
속성: vid.title = "대두족장 객체지향성 원론".vid.num_likes = 100
메소드: vid.play(), vid.pause()

다음을 속성과 메소드로 설명해 보세요. 속성은 명사/형용사, 메소드는 동사여야 합니다.

인간, 게시판 글, 피아노, 휴대폰, Ben E. King의 "Stand By Me"

```
아주 단순하게는, '속성'을 특성(특징)/상태, '메소드'를 행동/활동으로 정의할 수 있겠습니다.

[인간(Human)]

# 속성
Human.name = "WonSeok Kim"  # Human은 이름을 가지고 있다.
Human.height = 174         # Human은 키를 가지고 있다.
Human.weight = 75          # Human은 몸무게를 가지고 있다.
Human.sex = "male"         # Human은 성별을 가지고 있다.
Human.emotion = "happy"    # Human은 감정을 가지고 있다.

# 메소드
Human.speak()   # Human은 말할 수 있다.
Human.eat()     # Human은 먹을 수 있다.
Human.walk()    # Human은 걸을 수 있다.
Human.think()   # Human은 생각할 수 있다.

```
```
[게시판 글(Post)]

# 속성
Post.title = "대두족장 객체지향성 원론 숙제(퀴즈)"  # Post는 제목을 가지고 있다.
Post.author = "WonSeok Kim"  # Post는 작성자를 가지고 있다.
Post.date_created = "2024-09-17"  # Post는 작성일자를 가지고 있다.

# 메소드
Post.save()     # Post는 저장할 수 있다.
Post.delete()   # Post는 삭제할 수 있다.
Post.correct()  # Post는 수정할 수 있다.
Post.like()     # Post는 좋아요를 누를 수 있다.
```
```
[피아노(Piano)]

# 속성
Piano.brand = "Steinway"  # Piano는 브랜드를 갖고 있다.
Piano.color = "Black"    # Piano는 색깔을 갖고 있다.
Piano.model = "B-211"    # Piano는 모델을 갖고 있다.

# 메소드
Piano.play()   # Piano는 연주할 수 있다.
Piano.stop()   # Piano는 멈출 수 있다.
Piano.open_lid()   # Piano는 뚜껑을 열 수 있다.
Piano.tune()   # Piano는 조율할 수 있다.
```
```
[휴대폰(Phone)]

# 속성
Phone.brand = "Apple"  # Phone은 브랜드를 갖고 있다.
Phone.color = "White"  # Phone은 색깔을 갖고 있다.
Phone.model = "iPhone 15 Pro"  # Phone은 모델명을 갖고 있다.

# 메소드
Phone.call()   # Phone은 전화를 걸 수 있다.
Phone.text()   # Phone은 문자를 보낼 수 있다.
Phone.internet()   # Phone은 인터넷을 할 수 있다.
Phone.camera()     # Phone은 촬영할 수 있다.
```
```
[Stand By Me]

# 속성
Stand By Me.artist = "Ben E. King"  # Stand By Me는 아티스트를 가지고 있다.
Stand By Me.genre = "R&B"  # Stand By Me는 장르를 가지고 있다.
Stand By Me.release_year = "1961-04-24"  # Stand By Me는 발매일을 가지고 있다.

# 메소드
Stand By Me.play()  # Stand By Me는 재생할 수 있다.
Stand By Me.pause()  # Stand By Me는 일시정지할 수 있다.
Stand By Me.stop()  # Stand By Me는 멈출 수 있다.
Stand By Me.repeat()  # Stand By Me는 반복할 수 있다.
```

### ***2***

세상 만물을 그려본다면 점(vertex), 선(edge), 면(face)으로 단순화할 수 있습니다. 점->선->면 순으로 진화합니다. 면은 선에서, 선은 점에서 상속 받습니다.

세상에 곡선은 없습니다. 객체지향적으로 설명해보세요

```
세상 만물을 '점에서 면으로 진화하는 것'으로 설명한다면, 선과 면은 점이라는 가장 원시적인 조상 클래스로부터 상속 받아 각각의 다형성을 보이는 것으로 볼 수 있습니다. 

즉, '점'은 공간에서 '위치(position)'라는 속성을 갖습니다. '이동(move)'라는 method를 가집니다. '선'은 '점'으로부터 상속 받으므로 '점'의 속성(위치)과 '이동'이라는 method를 가지며, 다형성으로써 '길이 계산(length)'과 같은 method를 overriding함으로써 개성을 갖습니다.

'면'은 '선'의 연속입니다. 선들이 일종의 닫힌 곡선을 형성하며 면적을 가집니다. '선'에서 상속 받으므로 '선'의 속성과 method를 가지며, 다형성으로써 '면적 계산(area)'과 같은 method를 overriding함으로써 개성을 갖습니다.

'곡선'은 "무한히 '짧은 직선'의 연속 및 합"으로 표현할 수 있겠고, 따라서 '곡선'이라는 새로운 클래스가 필요하지 않습니다. 이는 미적분학에서 '곡선'을 극한의 수준에서 무한히 작은 직선의 합으로 계산하는 이치와 동일합니다. 즉, '곡선'은 직선의 또다른 형태, 즉 다형성으로 설명 가능합니다.

따라서 '세상에 곡선은 없습니다'
```

### ***3***

진짜 생명체만 객체로 오해하면 안됩니다. 세상 만물+개념까지도 진화 가능한 생명체로 보여야 합니다. 생물학에서 다루는 생명체가 아닙니다.

민주주의 조상 클래스를 객체지향적으로 설명하세요.

```
'조상 클래스로부터 상속받아 각자의 다형성을 발현한다'고 보는 것이 '객체지향'을 제대로 이해하는 방법이겠습니다만, 객체지향의 3대 축인 '상속성', '다형성', '캡슐화'에 더해 '추상화(Abstraction)'를 활용한다면 한 객체의 조상 클래스를 좀 더 용이하게 파악할 수 있겠고, 따라서 세상 만물을 더욱더 '객체지향적'으로 바라보는데 도움이 됩니다.

우선 '민주주의'의 속성(특징) 중 어떤 것에 초점을 맞추느냐에 따라 비교 분석의 대상이 달라질 수 있습니다. '민주주의'를 정치 체제의 관점에서 본다면 다른 비교 대상으로 '귀족제'와 '독재(군주제)'가 있고, 경제 체제의 관점에서 본다면 '사회주의'가 비교 대상으로 적절합니다. 엄밀히는, 민주주의-사회주의, 자본주의-공산주의가 통상적인 구분입니다만, 여기서는 민주주의와 사회주의의 특성상 자본주의와 공산주의를 속성으로 갖게 된다는 측면이 있기 때문에 '경제 체제'로서의 속성을 기준으로도 분석해보겠습니다. 정치 체제란 '국가의 권력을 어떻게 나누고 운영하는지'에 관한 것이고, 경제 체제는 '자원을 어떻게 배분하고 소유하는지'에 관한 것입니다.

정치 체제의 속성으로는 `통치 방식(Governance)`, `대표성(Representation)`, `(정치적) 자유(Freedom)`, '(정치적) 평등(Equality)'이 있습니다. 

경제 체제의 속성으로는 `사유재산(Property)`, `(재산권 행사의) 자유(Freedom)`, `(결과적) 평등(Equality)`이 있습니다.

위의 기준에 따라 정리해보면 아래와 같습니다.

[민주주의의 속성]
- 정치적 속성
    `통치(governance)` - '선출된 대표들'에 의한 통치(의사결정)('governance'를 '통치'로 번역하는 것이 적절한가에 관하여는 의문이 있습니다)
    `대표성(representation)` - 모든 시민들의 참여
    `자유(freedom)` - 모든 시민들의 정치적 자유 보장
    `평등(equality)` - 모든 시민들의 정치적 평등
- 경제적 속성
    `사유재산(property)` - True
    `자유(freedom)` - 모든 시민들의 재산권 행사의 자유 보장
    `결과적 평등(equality)` - False

[민주주의의 method]
`시민들의 투표(vote)`
`시민들 또는 대표들의 입법(legislation)`
`시민들 또는 정당성을 부여받은 존재(법관)의 판결(judgement)`이 있습니다.

[독재의 속성] - 정치적 속성만 짚겠습니다.
`통치(governance)` - 왕 또는 군주와 같이 '한 명 또는 소수의 통치자'
`대표성(representation)` - 없음
`자유(freedom)` - 정치적 자유 없음
`평등(equality)` - 정치적 평등 없음

[독재의 method]
`왕 또는 군주의 판결(judgement)`
`왕 또는 군주의 명령(rule)

[귀족제의 속성] - 마찬가지로, 정치적 속성만 짚겠습니다.
`통치(governance)` - 소수 엘리트의 통치
`대표성(representation)` - 제한적 대표성
`자유(freedom)` - 제한적 자유
`평등(equality)` - 제한적 평등

[귀족제의 method]
`소수 엘리트의 통치(rule)`
`소수 엘리트의 법 제정(legislation)`
`소수 엘리트의 판결(judgement)`

[사회주의의 속성] - 여기서는 경제적 속성만 짚겠습니다.
`사유재산(property)` - False
`자유(freedom)` - 사회를 위해 국민들의 재산권 행사의 자유 제한
`결과적 평등(equality)` - True

[사회주의의 method]
`자원의 재분배`

이제 `민주주의의 조상 클래스`를 설명해보겠습니다.

[정치 체제의 관점에서]

민주주의, 귀족제, 독재의 공통 분모가 되는 속성들로는, `권력을 행사하고 국가를 통치하는 주체(Governance)`, `통치주체가 국민들을 얼마나 잘 대표하는지(Representation)`, `시민들의 정치적 자유(Freedom)가 얼마나 보장되는지`, `시민들의 정치적 참여의 기회(Equality)가 얼마나 보장되는지`가 있습니다. 

따라서 정치 체제의 관점에서 민주주의의 조상 클래스는 `class PoliticalSystem`으로 정의할 수 있겠고, 그 parameter로는 `Governance`, `Representation`, `Freedom`, `Equality`가 있습니다. 

[경제 체제의 관점에서]

민주주의와 사회주의의 공통 분모가 되는 속성들은 `사유재산(Property)`과 `경제적 평등(Equality)`, `재산권 행사의 자유(Freedom)`가 있습니다. 

따라서 경제 체제의 관점에서 민주주의의 조상 클래스는 `class EconomicSystem`으로 정의할 수 있겠고, 그 parameter로는 `Property`, `Equality`, `Freedom`가 있습니다.
```
```python
민주주의의 조상 클래스를 코드로 작성해본다면 다음과 같습니다.

class PoliticalSystem:
    def __init__(self, governance, representation, freedom, equality):
        self.governance = governance  # 통치 주체
        self.representation = representation  # 대표성
        self.freedom = freedom  # 정치적 자유
        self.equality = equality  # 정치적 평등

    def describe_system(self):
        return f"Governance: {self.governance}, Representation: {self.representation}, Freedom: {self.freedom}, Equality: {self.equality}"

class EconomicSystem:
    def __init__(self, property, equality, freedom):
        self.property = property  # 사유재산
        self.equality = equality  # 경제적 평등
        self.freedom = freedom  # 재산권 자유

    def describe_system(self):
        return f"Property: {self.property}, Equality: {self.equality}, Freedom: {self.freedom}"
```

### ***4***

모든 클래스의 최고 조상 클래스는 어차피 가장 단순화된 Generic Object 여야 합니다. 따라서 특정 클래스의 조상 클래스를 찾으려면 Generic Object에서 어느 정도 진화한 종특이 드러나는 클래스여야 합니다.

```
GenericObject👉...👉Weapon👉...👉Pistol
GenericObject👉...👉Weapon👉...👉Missile
GenericObject👉...👉Vehicle👉...👉Bicycle
GenericObject👉...👉Vehicle👉...👉Helicopter
GenericObject👉...👉Vehicle👉...👉Boat
GenericObject👉...👉Vehicle👉...👉WeaponizedVehicle👉...👉Tank
```

종특 조상 클래스: Weapon, Vehicle

다시, 민주주의의 조상 클래스를 객체지향적으로 설명하세요.

```
위에서는 제가 '민주주의'를 정치 체제(Political System)와 경제 체제(Economic System)로 나누어 답변하였지만, GenericObject를 고려한다면 정치 체제와 경제 체제를 통합하는 조상 클래스까지 설명 가능하겠습니다.

즉, 제가 위에서 답변한 내용은 아래와 같이 정리될텐데,

GenericObject👉...👉PoliticalSystem👉...👉Democracy, Aristocracy, Dictatorship
GenericObject👉...👉EconomicSystem👉...👉Democracy(Capitalism), Socialism(Communism)

PoliticalSystem과 EconomicSystem의 조상 클래스를 아우르는 바로 윗단계의 조상 클래스로 `System` 클래스가 있습니다.  `System` 클래스는 PoliticalSystem은 물론 EconomicSystem, CulturalSystem, SocialSystem 등등을 모두 아우르는 상위 클래스이고, 각각의 하위 System들은 `System` 클래스가 갖고 있는 속성과 method들을 상속 받으면서 각자의 다형성으로 overriding하여 개성을 발현합니다.

`System` 클래스의 속성으로는, `목적(Purpose)`, `구조(Structure)`를 생각해볼 수 있습니다.

소스코드로는, 다음과 같습니다. 제가 사회체제, 문화체제 등에 관하여는 잘 알지 못하여 정확하지 않을 수 있습니다.
```
```python
class System:
    def __init__(self, purpose, structure):
        self.purpose = purpose  # 목적
        self.structure = structure  # 구조

    def describe(self):
        return f"System with purpose: {self.purpose}, Structured as: {self.structure}"
```
```
GenericObject👉...👉System👉PoliticalSystem👉Democracy, Dictatorship, Aristocracy
GenericObject👉...👉System👉EconomicSystem👉Democracy(Capitalism), Socialism(Communism)
GenericObject👉...👉System👉CulturalSystem👉TraditionalCulture, ModernCulture, Multiculture
GenericObject👉...👉System👉SocialSystem👉ClassSociety, EgalitarianSociety
```

### ***5***

내연기관차와 전기차의 차이를 객체지향적으로 설명하세요.

조상 클래스, 상속성과 다형성이 드러나야 합니다.

```
우선 내연기관차(Internal Combustion Engine Vehicle)와 전기차(Electric Vehicle)의 공통점과 차이점부터 살펴보면,

[공통점]

둘 모두 `flyable`이 아니고 `탈 것(Vehicle)`이며, `drivable(autonomous)`의 유무로 구분 가능하며,  `동력기관(Power_Unit)`, `동력원(Power_Source)`을 가지고 있습니다. 그리고 `이동(Move)`, `멈춤(Stop)`을 할 수 있습니다. 

[차이점]

ICE 차량은 `엔진(engine)`을 가지고 있고 `연료(fuel)`를 소모해 작은 폭발을 일으켜 `실린더(cylinder)`를 움직여 `운전(drive)`합니다. 가솔린(gasoline), 디젤(diesel) 등이 대표적인 `연료 타입(fuel type)`입니다. `마력(horsepower)`, `토크(torque)` 등이 성능을 결정짓는 요소이고, `변속기(transmission)`를 통해 속도를 조절합니다.

반면, EV는 `모터(Motor)`를 가지고 있고, `전기(Electricity)`를 소모해 `운전(Drive)`합니다. `배터리(Battery)`가 대표적인 `전기 저장 장치(Electric Storage Device)`이고, `충전기(Charger)`를 통해 전기를 충전합니다. `충전 시간(Charge Time)`, `주행 거리(Driving Range)` 등이 성능을 결정짓는 요소이고, `인버터(Inverter)`를 통해 직류 전기를 교류로 변환합니다.

이를 Bottom Up 방식으로 분석해보면, `(Drivable) Vehicle` 조상 클래스가 있겠고, 둘의 차이점들이 곧 각각의 개성 및 다형성이라고 할 수 있습니다.

따라서, 다음과 같습니다.

GenericObject👉...👉Vehicle👉...👉Drivable Vehicle👉ICE Vehicle
GenericObject👉...👉Vehicle👉...👉Drivable Vehicle👉EV
```
```
그리고 다음과 같이 코드로 작성해볼 수 있습니다.
```
```python

# Vehicle 클래스: 모든 탈 것의 기본 클래스
class Vehicle:
    def __init__(self, name, power_unit, power_source, seats):
        self.name = name  # 탈 것의 이름
        self.power_unit = power_unit  # 동력 기관 (엔진 또는 모터)
        self.power_source = power_source  # 동력원 (연료 또는 전기)
        self.seats = seats  # 좌석 수
        self.flyable = False  # 비행 가능 여부

    def move(self):
        print(f"{self.name}가 {self.power_source}로 구동되는 {self.power_unit}을 사용하여 이동합니다.")

    def stop(self):
        print(f"{self.name}가 멈췄습니다.")

    def show_info(self):
        print(f"탈 것 이름: {self.name}")
        print(f"동력 기관: {self.power_unit}")
        print(f"동력원: {self.power_source}")
        print(f"좌석 수: {self.seats}")
        print(f"비행 가능 여부: {'예' if self.flyable else '아니오'}")

# DrivableVehicle 클래스: 운전 가능한 탈 것
class DrivableVehicle(Vehicle):
    def __init__(self, name, power_unit, power_source, seats, autonomous=False):
        super().__init__(name, power_unit, power_source, seats)
        self.autonomous = autonomous  # 자율주행 여부

    def drive(self):
        if self.autonomous:
            print(f"{self.name}가 자율주행 모드로 주행합니다.")
        else:
            print(f"{self.name}가 운전됩니다.")

    def show_info(self):
        super().show_info()
        print(f"자율주행: {'예' if self.autonomous else '아니오'}")

# ICEVehicle 클래스: 내연기관차
class ICEVehicle(DrivableVehicle):
    def __init__(self, name, engine, fuel_type, horsepower, torque, transmission, seats, autonomous=False):
        super().__init__(name, engine, fuel_type, seats, autonomous)
        self.engine = engine  # 엔진
        self.fuel_type = fuel_type  # 연료 타입
        self.horsepower = horsepower  # 마력
        self.torque = torque  # 토크
        self.transmission = transmission  # 변속기

    def ignite(self):
        print(f"{self.name}의 {self.engine}이 점화되었습니다. 실린더가 움직입니다.")

    def change_gear(self):
        print(f"{self.name}의 {self.transmission} 변속기가 기어를 변경합니다.")

    def show_performance(self):
        print(f"{self.name}의 성능:")
        print(f"마력: {self.horsepower}hp")
        print(f"토크: {self.torque}Nm")
        print(f"변속기: {self.transmission}")

    def show_info(self):
        super().show_info()
        print(f"엔진: {self.engine}")
        print(f"연료 타입: {self.fuel_type}")
        self.show_performance()

# ElectricVehicle 클래스: 전기차
class ElectricVehicle(DrivableVehicle):
    def __init__(self, name, motor, battery_capacity, charge_time, driving_range, seats, autonomous=False):
        super().__init__(name, motor, "전기", seats, autonomous)
        self.motor = motor  # 모터
        self.battery_capacity = battery_capacity  # 배터리 용량 (kWh)
        self.charge_time = charge_time  # 충전 시간
        self.driving_range = driving_range  # 주행 거리 (km)
        self.inverter = "표준 인버터"  # 인버터

    def charge_battery(self):
        print(f"{self.name}의 배터리를 충전 중입니다.")

    def convert_current(self):
        print(f"{self.name}의 인버터가 직류를 교류로 변환하고 있습니다.")

    def show_performance(self):
        print(f"{self.name}의 성능:")
        print(f"배터리 용량: {self.battery_capacity}kWh")
        print(f"충전 시간: {self.charge_time}시간")
        print(f"주행 거리: {self.driving_range}km")

    def show_info(self):
        super().show_info()
        print(f"모터: {self.motor}")
        self.show_performance()

# 객체 생성 및 사용 예시

# ICE 차량 객체 생성
bmw = ICEVehicle(
    name="BMW 3 시리즈",
    engine="V6 엔진",
    fuel_type="가솔린",
    horsepower=300,
    torque=400,
    transmission="자동",
    seats=5,
    autonomous=False
)

# EV 차량 객체 생성
tesla = ElectricVehicle(
    name="테슬라 모델 3",
    motor="전기 모터",
    battery_capacity=75,
    charge_time=8,
    driving_range=500,
    seats=5,
    autonomous=True
)

# 메소드 호출
print("\n[ 내연기관차 정보 ]")
bmw.show_info()
bmw.move()
bmw.drive()
bmw.ignite()
bmw.change_gear()
bmw.stop()

print("\n[ 전기차 정보 ]")
tesla.show_info()
tesla.move()
tesla.drive()
tesla.charge_battery()
tesla.convert_current()
tesla.stop()
```

output:
```
[ 내연기관차 정보 ]
탈 것 이름: BMW 3 시리즈
동력 기관: V6 엔진
동력원: 가솔린
좌석 수: 5
비행 가능 여부: 아니오
자율주행: 아니오
엔진: V6 엔진
연료 타입: 가솔린
BMW 3 시리즈의 성능:
마력: 300hp
토크: 400Nm
변속기: 자동
BMW 3 시리즈가 가솔린로 구동되는 V6 엔진을 사용하여 이동합니다.
BMW 3 시리즈가 운전됩니다.
BMW 3 시리즈의 V6 엔진이 점화되었습니다. 실린더가 움직입니다.
BMW 3 시리즈의 자동 변속기가 기어를 변경합니다.
BMW 3 시리즈가 멈췄습니다.

[ 전기차 정보 ]
탈 것 이름: 테슬라 모델 3
동력 기관: 전기 모터
동력원: 전기
좌석 수: 5
비행 가능 여부: 아니오
자율주행: 예
모터: 전기 모터
테슬라 모델 3의 성능:
배터리 용량: 75kWh
충전 시간: 8시간
주행 거리: 500km
테슬라 모델 3가 전기로 구동되는 전기 모터을 사용하여 이동합니다.
테슬라 모델 3가 자율주행 모드로 주행합니다.
테슬라 모델 3의 배터리를 충전 중입니다.
테슬라 모델 3의 인버터가 직류를 교류로 변환하고 있습니다.
테슬라 모델 3가 멈췄습니다.
```
```
쉽게 생각하고 덤볐다가, 정말 엄청 헤맸습니다. 진짜 맨땅에 헤딩한 느낌입니다😂
```


### ***6***

한국어, 영어, 일본어, 중국어의 조상 클래스를 설명하세요.

한국어, 영어, 일본어, 중국어의 상속성과 다형성을 설명하세요.

그 언어를 몰라도 상식선에서 객체지향적으로 설명은 할 수 있어야 합니다.

-------------------
객체들의 조상 클래스를 찾으려면 각 객체들의 공통점부터 생각해봐야겠지. 뭐가 같은게 있어야 상속을 받았다고 할 수 있는 것이고
조상 클래스가 존재할거잖아.

같은 점이 1도 없는데 '객체지향적 분석'하겠다고 노력하면 결국 시간낭비일 수 있다는거지. 물론, 분석하는 사람의 호라이즌이
얼마나 넓고 좁으냐에 따라 그 공통점이 보일 수도, 안보일 수도 있겠고, 시도하는 과정에서 몰랐던 공통점과 차이점 등을 알게돼서
객체지향적 분석이 '가능해질 수도' 있겠지만 기본적으로 '상식선'에서 파악해서 '평균의 수준'에서는 행할 수 있어야 하니까.

각 언어들의 공통점들을 찾아보자. 속성과 메소드를 따지기 전에 그냥 공통점부터 생각해보는거야. 일단, `의사소통의 수단`이고 
매개야. 자신의 감정을 표현하거나, 정보를 전달하거나, 명령을 내리거나, 질문을 하기 위한 수단이지.

그리고, `사고의 수단`이기도 해. Yann Lecun 같은 학자는 '사고하기 위해 언어가 반드시 필요한 것이 아니다'라는 취지로 말하고, 
확실히 수학적인 부분은 반드시 언어가 필요한 것이 아니긴 하지. 그러나, 언어가 없다면 대부분의 사고 범위는 제한될 수 밖에 없고, 언어로 인해 사고의
선명함이 증가되는 것은 부인할 수 없어. 사고의 폭이나 풍부함이 언어에 의해 제한되기도, 넓어지기도 한다는 점에서 사고와 언어는 아주 밀접한 관련이 있다고 봐야해.

문득 '수학적 개념'으로만 의사소통하는 외계 종족을 생각해볼 수도 있겠다. 호라이즌이 곧 어디까지 상상할 수 있는지를 결정해.

영어 단어를 통해 더욱 선명하고 풍부하게 사고가 이뤄질 수 있는 개념들을 생각해보면 사고와 언어의 관련성은 절대 무시할 수 없어.
예를 들어, 'Procrastination'라는 단어를 생각해보자. 한국어로는 '미루기', '행동 지연' 정도로 번역할 수 있지만, 'Procrastination'은 단순한 지연보다는 심리적 요인과 패턴을 포함한
개념으로 알고 있어. 일시적이고 일회적인 것과는 약간 다른 개념이지.

그리고 각 언어는 `문자`를 갖고 있어. 내가 아는한 모든 언어는 그에 상응하는 `문자`가 있어. `문자`가 있다면 그에 맞는 `문법`도 존재하지.
즉, 모든 언어들은 단순한 문자의 나열에 그치지 않는다는 거야. `문법`이 있어야 그 문자들이 의미를 갖게 되고, 그 의미를 통해 `의사소통`이 가능해지잖아.

영화 'Arrival'에 등장하는 외계의 언어까지 생각해보자. 'Arrival'에 등장하는 외계의 언어는 시간의 흐름을 '비선형적'으로 인식할 수 있게 하는 언어로, '시간'적인 개념까지 '언어'로써 표현할 수 있는 언어야. 

영화 한편이 주는 통찰과 호라이즌이 너무 다양하네. 나는 'Arrival'을 통해 자신의 운명을 바꿀 수 있는 '선택의 힘'만 알아차렸다고 생각했는데 부지불식 간에 언어학적 호라이즌까지 조금이나마 넓힐 수 있었어.

놀랍다.

아무튼 분명히 외계의 언어 역시 `의사소통의 수단`이고, `사고의 수단`이고, `문자`와 `문법`을 가지고 있다는 사실을 알 수 있어.

청각 장애인들의 수화도 언어야. 수화의 동작을 그림으로 그리면 `문자`가 되고, 그 `문자`들의 조합이 `문법`이 되고, 그 `문자`와 `문법`을 통해 `의사소통`이 가능해지는거야. 그리고, 수화 역시 `사고의 수단`이 되는거지.

소름 돋는다. 외계의 언어부터 청각 장애인들의 언어까지 객체지향적으로 분석하면 비교 대조가 가능해지고, 더 선명하게 이해할 수 있어.

그야말로 치트키구나. 모든 개념은 비교와 대조를 행할 때 비로소 온전히 이해될 수 있어. 객체지향이 그토록 중요한 이유겠지.

자 이제 조상 클래스를 생각해보자. 가장 쉽게 파악할 수 있는 한국어, 영어, 일본어, 중국어의 조상 클래스는 `인간의 언어` 클래스야.

아니면 `Language` 클래스에 `HumanLanguage`와 `AlienLanguage`의 클래스 구분을 위해 `Human=True` 라는 속성을 넣을 수도 있어.

`Language` 클래스는 `의사소통`, `사고`, `문자`, `문법`을 가지고 있어야겠지. 그리고, `인간의 언어` 클래스의 하위 클래스로 `동양 언어`와 `서양 언어`라는 클래스가
있겠어. 그런데, 단순히 지역적인 분류로 나누는 것보다는 특징으로 구분하는 것이 더 그 언어의 특징을 파악
하기 쉬울 수도 있어. 그렇게 따지면 족장님께서 말씀해오셨듯, 중국어와 영어를 한 그룹으로 묶고, 한국어와 일본어를 한 그룹으로 묶는 것이 적절할 수 있어.

일단 나의 지식 범위 내에서 지역적인 분류로써 `EasternLanguage`와 `WesternLanguage`로 구분해보자. Python에서는 가급적 객체나 클래스를 소문자로 시작하는 것이 관례라고 해. 이건 pep 8의 가이드이기도 하지.

하지만, 오늘은 선명한 사고를 위해 약간의 예외를 허용하자.

`한국어`와 `영어`, `일본어`, `중국어`들의 조상 클래스를, `Language` 클래스 또는 `HumanLanguage`로 정의하고, 속성들로는 `communication`, `thinking`, `characters`, `grammar`들을, `describe`라는 단순한 메소드를 생각해볼 수 있어.

그리고 그 하위 클래스로 지역적 분류에 따라 'EasternLanguage'와 'WesternLanguage' 라는 하위 클래스들을 생각해볼 수 있겠지. 지역에 따른 하위 클래스들에는 `region`이라는 속성으로 overriding 할 수 있어.

그리고 `한국어`, `영어`, `중국어`, `일본어`의 각 객체들은 조상들로부터 속성과 메소드를 쭉 상속받으면서 저마다의 독특한 특성을 통해 다형성을 보여줄 수 있겠지.

와 이쯤되니까 언어에 관한 호라이즌의 한계를 느끼게 되는데 그래도 더 나아가보자.

일단 한국어의 특징으로는, 아주 뚜렷한 `높임말` 체계가 있어. `높임말`은 한국어의 가장 큰 특징 중 하나로 상대에 대한 존경이나 예의를 아주 세밀한 수준으로까지 표현할 수 있어. 

영어의 특징으로는, `관사`의 사용이 아주 뚜렷해. `a`, `an`, `the`와 같은 관사들을 사용해서 명사를 구체화하거나 일반화할 수 있어.

중국어에서는 `성조`가 아주 뚜렷한 것으로 알고 있어. `성조`에 따라 단어의 뜻이 달라지기 때문에 `성조`를 정확하게 발음하는 것이 중요한 것으로 알고 있어.

일본어의 뚜렷한 특징은 잘 모르겠지만, `가타카나`를 통한 외래어의 적극적 수용이 그 특징 중 하나로 알고 있어.

언어학에 대한 호라이즌이 넓고 깊은 사람들은 이런 특징들을 통해 언어의 특성을 파악할 수 있겠지. 그리고 그 특징의 정도를 아주 세밀하게 구분할 수 있는 속성들까지 파악할 수 있을거야. 이렇게 생각해보니, '객체지향적 분석과 사고'의 핵심은 결국 '호라이즌'이라는 것을 느끼게 된다. 

나는 `지역적 특징`으로만 분류했지만, `언어학적 특징`으로 분류한다면 또 다른 결과가 나올 수 있겠지. 그 외에 `기원`에 따른 분류를 할 수도 있을 것 같아.

언어학적 호라이즌이 아주 풍부한 사람의 객체지향적 분석이 너무 궁금하다. 그런 사람이라면 각 언어의 특징을 통해 그 언어가 가지는 '문화적 특성'까지 고려해서 분석이 가능할거야. 

```
저의 위 썰을 GPT o1-preview 에게 인풋으로 넣고 분석을 맡겼더니 다음과 같이 답변을 하였습니다.

객체지향적으로 언어들을 분석할 때, 풍부한 언어학적 호라이즌을 통해 각 언어의 
문화적 특성까지 고려해보자. 먼저, 모든 언어는 의사소통과 사고의 수단이며, 
문자와 문법을 가지고 있다는 공통점이 있다. 이 점을 기반으로 최상위 클래스인 Language를 정의할 수 있다.

그 다음으로 언어의 기원과 계통에 따라 하위 클래스를 나눌 수 있다. 
예를 들어, 인도유럽어족의 영어, 중국티베트어족의 중국어, 알타이어족의 
한국어와 일본어 등이 있다. 각 언어족 클래스는 해당 언어들이 공유하는 
문법적 특징과 역사적 배경을 속성으로 가질 수 있다.

이제 개별 언어로 내려와서, 각 언어의 독특한 특징을 생각해보자. 
한국어는 높임말 체계를 통해 사회적 위계와 예의를 표현하는 데 탁월하다. 
이는 한국 문화에서 존중과 조화를 중시하는 가치관이 반영된 것이다. 
또한, 한글이라는 독창적인 문자 체계를 사용하며, 음소 문자로서 발음과 문자의 일치도가 높다.

영어는 관사를 통해 명사의 특정성과 수를 명확하게 구분한다. 
이는 개체의 개별성과 명확성을 중요시하는 서구 문화의 영향을 받았다. 
또한, 라틴 문자를 사용하며, 전 세계적으로 통용되는 국제어로서의 지위를 가지고 있다.

중국어는 성조를 사용하여 단어의 의미를 구분한다. 
이는 중국어가 단음절어 중심의 언어이기 때문에 음의 높낮이로 의미를 
풍부하게 만드는 방법이다. 한자를 사용하는데, 이는 표의 문자로서 
하나의 글자가 의미를 담고 있어 역사와 전통이 깊다.

일본어는 가타카나를 통해 외래어를 적극적으로 수용한다. 이는 일본 
문화가 외부의 것을 받아들이고 자신들의 것으로 재해석하는 데 
능숙하다는 것을 보여준다. 또한, 히라가나, 가타카나, 한자를 혼용하여 사용하는 복잡한 문자 체계를 가지고 있다.

이러한 분석을 통해 각 언어의 문화적, 역사적 배경과 그에 따른 
언어적 특징을 객체지향적으로 모델링할 수 있다. 이는 단순히 
언어의 구조를 이해하는 것을 넘어, 그 언어를 사용하는 사람들의 
사고방식과 문화까지 깊이 있게 파악하는 데 도움을 준다. 
결국, 객체지향적 분석은 우리의 호라이즌을 넓혀주며, 서로 
다른 언어와 문화 사이의 공통점과 차이점을 명확하게 
이해할 수 있게 해주는 강력한 도구임을 다시 한 번 깨닫게 된다.
```

살짝 아쉽긴 하지만, 역시 제가 몰랐던 내용들까지 포함되어서 나름 만족스럽습니다.

### ***7***

음악 배울 때 다장조(C Major)와 라단조(A Minor)에서 출발하는 이유를 객체지향적으로 설명하세요.

---

나의 음악 관련 호라이즌이 극히 좁기 때문에 아주 기초적인 수준에서만 썰을 풀 수 있을 것 같아.

우선 장조와 단조의 개념부터 생각해보자. 다장조(C Major)는 'C(도) - B(시)'의 음들로 이뤄져있어. C로 시작하기 때문에 C Major가 되는 거지. 라단조(A Minor)는 `A(라) - G(솔)` 음들로 이뤄져있어. 마찬가지로 A로 시작하기 때문에 A Minor가 되는 거지. 내가 알기로 장조와 단조는 '온음 - 반음'의 구성으로 구별되는데, 더 간단히는 노래의 끝나는 음이 '도'냐, '라'냐로 대략적인 파악이 가능해.

특히 C Major와 A Minor는 반음 올리거나(#) 내린(b) 음을 쓰지 않고 화음도 그 안에서 결정돼. 이건 피아노를 기준으로 보면 검은 건반은 쓰지 않고 흰 건반만으로 연주가 가능한거야.

즉, A 음으로 시작해서 검은 건반을 쓰지 않으면 A Minor가 되는 거고, C 음으로 시작해서 검은 건반을 쓰지 않으면 C Major가 되는 식이지.

그리고 여기서 적절히 검은 건반을 추가하면서 변화를 주면 여러 조성을 만들어낼 수 있어.

결국, C Major와 A Minor는 아주 기본적인 클래스에 해당돼. 이 둘은 검은 건반, 반음을 사용하지 않기 때문에 가장 단순한 구조를 갖고 있어. 

그래서 피아노를 배울 때도 가장 먼저 배우는 것이고, 간단하게 익힐 수 있는 조성인 거지.

음악을 처음 배울 때 복잡한 조성, 검은 건반들을 가득 사용한 조성들부터 배우면 그 많은 조성들을 전부 개별적으로 외우고 익혀야 하니까 어떤 패턴이나 체계를 파악하기 너무 힘들어. 반면 처음부터 C Major와 A Minor를 익히면 그 다음부터는 그 토대에 적절히 개성들만 부여하는 식으로, 마치 레고에서 foundation block을 만들어 놓고 그 위에 여러 블럭들을 쌓으면서 온갖 것들을 만들어내는 것과 같아. 그래야 큰 그림이 보이고 조성에 대한 이해도와 응용력이 높아질 수 있어.

이렇게 보면 온갖 다양한 조성들의 조상 클래스를 C Major와 A Minor로 정의할 수 있고, C Major와 A Minor에서 상속 받은 속성과 메소드를 기초로 조금씩 변화를 부여하면서 다형성을 발현하면 얼마든지 다양한 조성들을 만들어낼 수 있어.

그래서 음악을 배울 때 C Major와 A Minor에서 출발하는 것이 효율적이고 효과적인 거야.
---

마찬가지로 GPT o1-preview 에게 물어봤습니다. 이번에는 그냥 질문만 던져봤는데, 아주 깔끔하게 답변을 해준 것 같습니다.

다른 인풋 지식도 없고, pre-trained된 모델 그 자체라서 질문만으로 모든 맥락과 내용을 파악하고 답변한 것입니다.

![alt text](images/003/image.png)
![alt text](images/003/image-1.png)
![alt text](images/003/image-2.png)

### ***8***

그림 배울 때 기본 도형(정육면체, 구, 원통, 원뿔)을 활용하는 이유를 객체지향적으로 설명하세요.

### ***9***

인체(여러분 몸)에서 정육면체, 구, 원통, 원뿔 등 기본 도형에서 진화할 수 있는 부위를 찾아 객체지향적으로 설명해보세요.

예) 머리의 상악 위쪽 부분(아래턱이 하악) 두개골은 구에 해당하고 상완은 원통 또는 직육면체에 가깝습니다.

### ***10***

맛의 기본은 짠맛, 단맛, 기름맛이며, 동양쪽으로 오면 감칠맛(우마미)이 추가되고 대부분 요리는 향신료와 양념으로 마무리됩니다.

라면이 맛있는 이유를 객체지향적으로 설명하세요.

신라면과 나가사끼 짬뽕 라면의 진화 계층 구조(조상 클래스)를 그려보세요.

신라면과 나가사끼 짬뽕 라면을 객체지향적으로 설명해보세요.

### ***11***

소리는 파동에서 상속받습니다. 빛 역시 파동에서 상속 받지만, 빛은 입자에서도 다중 상속을 받습니다. 파동이라는 조상 클래스 덕분에 소리와 빛은 장애물을 피하는 방식이 비슷합니다. 조상 클래스가 파동이고, 후손 클래스가 오버라이드하지 않는 한 이 파동 성질은 사라지지 않습니다.

물 수제비 역시 파동입니다.

물 수제비, 소리, 빛의 파동성을 객체지향적으로 설명해 보세요.

물 수제비, 소리, 빛이 장애물을 만났을 때 어떤 행태를 보이는지, 왜 그러는지 객체지향적으로 설명해보세요.

빛은 입자에서도 다중 상속을 받기 때문에 직진성도 있습니다. 당구공 튀듯 장애물에서 튕겨가기도 합니다. 빛의 파동성과 입자성을 실생활 경험을 살려 객체지향적으로 설명해보세요. 불꺼진 방에서 불켜진 공간으로 이어지는 문을 살짝만 열어봐도 알 수 있습니다.

### ***12***

이 유니버스가 객체지향적 엔진이라는 이유를 설명해 보세요.

인생이 객체지향적인 이유를 설명해보세요.

## ***무한반복***

성장하려면 리뷰하세요

12번까지 다 하셨으면 원론 영상 part 01, 02 다시 보고 오셔요. 다시 풀어보세요.

여기까지 했으면...

상위 0.0000000000001% 인정. 참 잘했어요.
